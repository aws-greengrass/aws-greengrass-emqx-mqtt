## EMQX Configuration Example

##

## @path listeners
listeners {
  ## @path listeners.tcp
  ## @type map_struct()

  # listeners are enabled by default, disable them
  ssl.default.enabled = false
  tcp.default.enabled = false
  ws.default.enabled = false
  wss.default.enabled = false

  ## @path listeners.ssl
  ## @type map_struct()
  ssl.mtls  =
  ## @path listeners.ssl.$name
    {
      ## @doc Enable listener.
      ## @path listeners.ssl.$name.enabled
      ## @type boolean()
      ## @default true
      enabled  =  true

      ## @doc IP address and port for the listening socket.
      ## @path listeners.ssl.$name.bind
      ## @type union() emqx_schema:ip_port() | integer()
      ## @default 8883
      bind  =  8883

      ## @doc The size of the listener's receiving pool.
      ## @path listeners.ssl.$name.acceptors
      ## @type pos_integer()
      ## @default 16
      #  acceptors  =  16

      ## @doc The maximum number of concurrent connections allowed by the listener.
      ## @path listeners.ssl.$name.max_connections
      ## @type union() infinity | pos_integer()
      ## @default infinity
      #  max_connections  =  infinity

      ## @doc When publishing or subscribing, prefix all topics with a mountpoint string.
      ## The prefixed string will be removed from the topic name when the message
      ## is delivered to the subscriber. The mountpoint is a way that users can use
      ## to implement isolation of message routing between different listeners.
      ## For example if a client A subscribes to `t` with `listeners.tcp.\<name>.mountpoint`
      ## set to `some_tenant`, then the client actually subscribes to the topic
      ## `some_tenant/t`. Similarly, if another client B (connected to the same listener
      ## as the client A) sends a message to topic `t`, the message is routed
      ## to all the clients subscribed `some_tenant/t`, so client A will receive the
      ## message, with topic name `t`.</br>
      ## Set to `""` to disable the feature.</br>
      ##
      ## Variables in mountpoint string:
      ##   - <code>${clientid}</code>: clientid
      ##   - <code>${username}</code>: username
      ## @path listeners.ssl.$name.mountpoint
      ## @type binary()
      ## @default ""
      #  mountpoint  =  ""

      ## @doc The configuration zone to which the listener belongs.
      ## @path listeners.ssl.$name.zone
      ## @type atom()
      ## @default default
      #  zone  =  default

      ## @doc Type of the rate limit.
      ## @path listeners.ssl.$name.limiter
      ## @type map_struct()
      ## @default {connection = "default"}
      #  limiter.ratelimit_name  =
      ## @path listeners.ssl.$name.limiter.$ratelimit_name
      ## @type emqx_limiter_schema:bucket_name()
      #  $ratelimit_name  =


      ## @doc Set <code>true</code> (default) to enable client authentication on this listener.
      ## When set to <code>false</code> clients will be allowed to connect without authentication.
      ## @path listeners.ssl.$name.enable_authn
      ## @type boolean()
      ## @default true
      enable_authn  =  true

      ## @doc The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny
      ## @path listeners.ssl.$name.access_rules
      ## @type array()
      ## @default ["allow all"]
      #  access_rules  =  ["allow all"]

      ## @doc Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>
      ## See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
      ## @path listeners.ssl.$name.proxy_protocol
      ## @type boolean()
      ## @default false
      #  proxy_protocol  =  false

      ## @doc Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.
      ## @path listeners.ssl.$name.proxy_protocol_timeout
      ## @type emqx_schema:duration()
      ## @default 3s
      #  proxy_protocol_timeout  =  3s

      ## @doc Per-listener authentication override.
      ## Authentication can be one single authenticator instance or a chain of authenticators as an array.
      ## When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.</br>
      ## @path listeners.ssl.$name.authentication
      ## @type array()
      ## @link listeners.tcp.$name.authentication
      #  authentication  =  []

      ## @path listeners.ssl.$name.tcp_options
      ## @link listeners.tcp.$name.tcp_options
      #  tcp_options {
      ## @doc Specify the {active, N} option for this Socket.</br>
      ## See: https://erlang.org/doc/man/inet.html#setopts-2
      ## @path listeners.ssl.$name.tcp_options.active_n
      ## @type integer()
      ## @default 100
      #  active_n  =  100

      ## @doc TCP backlog defines the maximum length that the queue of
      ##  pending connections can grow to.
      ## @path listeners.ssl.$name.tcp_options.backlog
      ## @type pos_integer()
      ## @default 1024
      #  backlog  =  1024

      ## @doc The TCP send timeout for the connections.
      ## @path listeners.ssl.$name.tcp_options.send_timeout
      ## @type emqx_schema:duration()
      ## @default 15s
      #  send_timeout  =  15s

      ## @doc Close the connection if send timeout.
      ## @path listeners.ssl.$name.tcp_options.send_timeout_close
      ## @type boolean()
      ## @default true
      #  send_timeout_close  =  true

      ## @doc The TCP receive buffer (OS kernel) for the connections.
      ## @path listeners.ssl.$name.tcp_options.recbuf
      ## @type emqx_schema:bytesize()
      #  recbuf  =  2KB

      ## @doc The TCP send buffer (OS kernel) for the connections.
      ## @path listeners.ssl.$name.tcp_options.sndbuf
      ## @type emqx_schema:bytesize()
      #  sndbuf  =  4KB

      ## @doc The size of the user-space buffer used by the driver.
      ## @path listeners.ssl.$name.tcp_options.buffer
      ## @type emqx_schema:bytesize()
      ## @default 4KB
      #  buffer  =  4KB

      ## @doc The socket is set to a busy state when the amount of data queued internally
      ##   by the VM socket implementation reaches this limit.
      ## @path listeners.ssl.$name.tcp_options.high_watermark
      ## @type emqx_schema:bytesize()
      ## @default 1MB
      #  high_watermark  =  1MB

      ## @doc The TCP_NODELAY flag for the connections.
      ## @path listeners.ssl.$name.tcp_options.nodelay
      ## @type boolean()
      ## @default true
      #  nodelay  =  true

      ## @doc The SO_REUSEADDR flag for the connections.
      ## @path listeners.ssl.$name.tcp_options.reuseaddr
      ## @type boolean()
      ## @default true
      #  reuseaddr  =  true
      #   }

      ## @path listeners.ssl.$name.ssl_options
      ssl_options {
        ## @doc Trusted PEM format CA certificates bundle file.</br>
        ## The certificates in this file are used to verify the TLS peer's certificates.
        ## Append new certificates to the file if new CAs are to be trusted.
        ## There is no need to restart EMQX to have the updated file loaded, because
        ## the system regularly checks if file has been updated (and reload).</br>
        ## NOTE: invalidating (deleting) a certificate from the file will not affect
        ## already established connections.
        ## @path listeners.ssl.$name.ssl_options.cacertfile
        ## @type binary()
        cacertfile  = ""

        ## @doc PEM format certificates chain file.</br>
        ## The certificates in this file should be in reversed order of the certificate
        ## issue chain. That is, the host's certificate should be placed in the beginning
        ## of the file, followed by the immediate issuer certificate and so on.
        ## Although the root CA certificate is optional, it should be placed at the end of
        ## the file if it is to be added.
        ## @path listeners.ssl.$name.ssl_options.certfile
        ## @type binary()
        certfile  = "etc/certs/cert.pem"

        ## @doc PEM format private key file.
        ## @path listeners.ssl.$name.ssl_options.keyfile
        ## @type binary()
        keyfile  = "etc/certs/key.pem"

        ## @doc Enable or disable peer verification.
        ## @path listeners.ssl.$name.ssl_options.verify
        ## @type enum: verify_peer | verify_none
        ## @default verify_none
        verify  =  verify_peer

        ## @doc Enable TLS session reuse.
        ## @path listeners.ssl.$name.ssl_options.reuse_sessions
        ## @type boolean()
        ## @default true
        #  reuse_sessions  =  true

        ## @doc Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.
        ## @path listeners.ssl.$name.ssl_options.depth
        ## @type integer()
        ## @default 10
        #  depth  =  10

        ## @doc String containing the user's password.
        ## Only used if the private key file is password-protected.
        ## @path listeners.ssl.$name.ssl_options.password
        ## @type string()
        #  password  =  ""

        ## @doc All TLS/DTLS versions to be supported.</br>
        ## NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>
        ## In case PSK cipher suites are intended, make sure to configured
        ## <code>['tlsv1.2', 'tlsv1.1']</code> here.
        ## @path listeners.ssl.$name.ssl_options.versions
        ## @type array()
        ## @default [tlsv1.3, tlsv1.2, tlsv1.1, tlsv1]
        versions  =  [tlsv1.3, tlsv1.2]

        ## @doc This config holds TLS cipher suite names separated by comma,
        ## or as an array of strings. e.g.
        ## <code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code> or
        ## <code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>.
        ## </br>
        ## Ciphers (and their ordering) define the way in which the
        ## client and server encrypts information over the network connection.
        ## Selecting a good cipher suite is critical for the
        ## application's data security, confidentiality and performance.
        ##
        ## The names should be in OpenSSL string format (not RFC format).
        ## All default values and examples provided by EMQX config
        ## documentation are all in OpenSSL format.</br>
        ##
        ## NOTE: Certain cipher suites are only compatible with
        ## specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')
        ## incompatible cipher suites will be silently dropped.
        ## For instance, if only 'tlsv1.3' is given in the <code>versions</code>,
        ## configuring cipher suites for other versions will have no effect.
        ## </br>
        ##
        ## NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>
        ## If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>
        ## PSK cipher suites: <code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
        ## RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
        ## RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
        ## RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code></br>
        ## @path listeners.ssl.$name.ssl_options.ciphers
        ## @type array()
        ## @default ["TLS_AES_256_GCM_SHA384", "TLS_AES_128_GCM_SHA256", "TLS_CHACHA20_POLY1305_SHA256", "TLS_AES_128_CCM_SHA256", "TLS_AES_128_CCM_8_SHA256", "ECDHE-ECDSA-AES256-GCM-SHA384", "ECDHE-RSA-AES256-GCM-SHA384", "ECDHE-ECDSA-AES256-SHA384", "ECDHE-RSA-AES256-SHA384", "ECDH-ECDSA-AES256-GCM-SHA384", "ECDH-RSA-AES256-GCM-SHA384", "ECDH-ECDSA-AES256-SHA384", "ECDH-RSA-AES256-SHA384", "DHE-DSS-AES256-GCM-SHA384", "DHE-DSS-AES256-SHA256", "AES256-GCM-SHA384", "AES256-SHA256", "ECDHE-ECDSA-AES128-GCM-SHA256", "ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-ECDSA-AES128-SHA256", "ECDHE-RSA-AES128-SHA256", "ECDH-ECDSA-AES128-GCM-SHA256", "ECDH-RSA-AES128-GCM-SHA256", "ECDH-ECDSA-AES128-SHA256", "ECDH-RSA-AES128-SHA256", "DHE-DSS-AES128-GCM-SHA256", "DHE-DSS-AES128-SHA256", "AES128-GCM-SHA256", "AES128-SHA256", "ECDHE-ECDSA-AES256-SHA", "ECDHE-RSA-AES256-SHA", "DHE-DSS-AES256-SHA", "ECDH-ECDSA-AES256-SHA", "ECDH-RSA-AES256-SHA", "ECDHE-ECDSA-AES128-SHA", "ECDHE-RSA-AES128-SHA", "DHE-DSS-AES128-SHA", "ECDH-ECDSA-AES128-SHA", "ECDH-RSA-AES128-SHA", "RSA-PSK-AES256-GCM-SHA384", "RSA-PSK-AES256-CBC-SHA384", "RSA-PSK-AES128-GCM-SHA256", "RSA-PSK-AES128-CBC-SHA256", "RSA-PSK-AES256-CBC-SHA", "RSA-PSK-AES128-CBC-SHA"]
        #  ciphers  =  ["TLS_AES_256_GCM_SHA384", "TLS_AES_128_GCM_SHA256", "TLS_CHACHA20_POLY1305_SHA256", "TLS_AES_128_CCM_SHA256", "TLS_AES_128_CCM_8_SHA256", "ECDHE-ECDSA-AES256-GCM-SHA384", "ECDHE-RSA-AES256-GCM-SHA384", "ECDHE-ECDSA-AES256-SHA384", "ECDHE-RSA-AES256-SHA384", "ECDH-ECDSA-AES256-GCM-SHA384", "ECDH-RSA-AES256-GCM-SHA384", "ECDH-ECDSA-AES256-SHA384", "ECDH-RSA-AES256-SHA384", "DHE-DSS-AES256-GCM-SHA384", "DHE-DSS-AES256-SHA256", "AES256-GCM-SHA384", "AES256-SHA256", "ECDHE-ECDSA-AES128-GCM-SHA256", "ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-ECDSA-AES128-SHA256", "ECDHE-RSA-AES128-SHA256", "ECDH-ECDSA-AES128-GCM-SHA256", "ECDH-RSA-AES128-GCM-SHA256", "ECDH-ECDSA-AES128-SHA256", "ECDH-RSA-AES128-SHA256", "DHE-DSS-AES128-GCM-SHA256", "DHE-DSS-AES128-SHA256", "AES128-GCM-SHA256", "AES128-SHA256", "ECDHE-ECDSA-AES256-SHA", "ECDHE-RSA-AES256-SHA", "DHE-DSS-AES256-SHA", "ECDH-ECDSA-AES256-SHA", "ECDH-RSA-AES256-SHA", "ECDHE-ECDSA-AES128-SHA", "ECDHE-RSA-AES128-SHA", "DHE-DSS-AES128-SHA", "ECDH-ECDSA-AES128-SHA", "ECDH-RSA-AES128-SHA", "RSA-PSK-AES256-GCM-SHA384", "RSA-PSK-AES256-CBC-SHA384", "RSA-PSK-AES128-GCM-SHA256", "RSA-PSK-AES128-CBC-SHA256", "RSA-PSK-AES256-CBC-SHA", "RSA-PSK-AES128-CBC-SHA"]

        ## @doc EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.
        ## @path listeners.ssl.$name.ssl_options.user_lookup_fun
        ## @type string()
        ## @default "emqx_tls_psk:lookup"
        #  user_lookup_fun  =  "emqx_tls_psk:lookup"

        ## @doc SSL parameter renegotiation is a feature that allows a client and a server
        ## to renegotiate the parameters of the SSL connection on the fly.
        ## RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
        ## you drop support for the insecure renegotiation, prone to MitM attacks.
        ## @path listeners.ssl.$name.ssl_options.secure_renegotiate
        ## @type boolean()
        ## @default true
        #  secure_renegotiate  =  true

        ## @doc Path to a file containing PEM-encoded Diffie-Hellman parameters
        ## to be used by the server if a cipher suite using Diffie-Hellman
        ## key exchange is negotiated. If not specified, default parameters
        ## are used.</br>
        ## NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.
        ## @path listeners.ssl.$name.ssl_options.dhfile
        ## @type string()
        #  dhfile  =

        ## @doc Used together with {verify, verify_peer} by an TLS/DTLS server.
        ## If set to true, the server fails if the client does not have a
        ## certificate to send, that is, sends an empty certificate.
        ## If set to false, it fails only if the client sends an invalid
        ## certificate (an empty certificate is considered valid).
        ## @path listeners.ssl.$name.ssl_options.fail_if_no_peer_cert
        ## @type boolean()
        ## @default false
        fail_if_no_peer_cert  =  true

        ## @doc An important security setting, it forces the cipher to be set based
        ##  on the server-specified order instead of the client-specified order,
        ##  hence enforcing the (usually more properly configured) security
        ##  ordering of the server administrator.
        ## @path listeners.ssl.$name.ssl_options.honor_cipher_order
        ## @type boolean()
        ## @default true
        #  honor_cipher_order  =  true

        ## @doc In protocols that support client-initiated renegotiation,
        ## the cost of resources of such an operation is higher for the server than the client.
        ## This can act as a vector for denial of service attacks.
        ## The SSL application already takes measures to counter-act such attempts,
        ## but client-initiated renegotiation can be strictly disabled by setting this option to false.
        ## The default value is true. Note that disabling renegotiation can result in
        ## long-lived connections becoming unusable due to limits on
        ## the number of messages the underlying cipher suite can encipher.
        ## @path listeners.ssl.$name.ssl_options.client_renegotiation
        ## @type boolean()
        ## @default true
        #  client_renegotiation  =  true
      }
    }


  ## @path listeners.ws
  ## @type map_struct()


  ## @path listeners.wss
  ## @type map_struct()


  ## @path listeners.quic
  ## @type map_struct()

 }
## @path mqtt
mqtt {
  ## @path mqtt.idle_timeout
  ## @type union() infinity | emqx_schema:duration()
  ## @default 15s
  idle_timeout  =  15s

  ## @path mqtt.max_packet_size
  ## @type emqx_schema:bytesize()
  ## @default 1MB
  max_packet_size  =  1MB

  ## @path mqtt.max_clientid_len
  ## @type 23..65535
  ## @default 65535
  max_clientid_len  =  65535

  ## @path mqtt.max_topic_levels
  ## @type 1..65535
  ## @default 128
  max_topic_levels  =  65535

  ## @path mqtt.max_qos_allowed
  ## @type qos()
  ## @default 2
  max_qos_allowed  =  2

  ## @path mqtt.max_topic_alias
  ## @type 0..65535
  ## @default 65535
  max_topic_alias  =  65535

  ## @path mqtt.retain_available
  ## @type boolean()
  ## @default true
  retain_available  =  true

  ## @path mqtt.wildcard_subscription
  ## @type boolean()
  ## @default true
  wildcard_subscription  =  true

  ## @path mqtt.shared_subscription
  ## @type boolean()
  ## @default true
  shared_subscription  =  true

  ## @path mqtt.exclusive_subscription
  ## @type boolean()
  ## @default false
  exclusive_subscription  =  false

  ## @path mqtt.ignore_loop_deliver
  ## @type boolean()
  ## @default false
  ignore_loop_deliver  =  false

  ## @path mqtt.strict_mode
  ## @type boolean()
  ## @default false
  strict_mode  =  false

  ## @path mqtt.response_information
  ## @type string()
  ## @default
  response_information  = ""

  ## @path mqtt.server_keepalive
  ## @type union() integer() | disabled
  ## @default disabled
  server_keepalive  =  disabled

  ## @path mqtt.keepalive_multiplier
  ## @type number()
  ## @default 1.5
  keepalive_multiplier  =  1.5

  ## @path mqtt.max_subscriptions
  ## @type union() 1..inf | infinity
  ## @default infinity
  max_subscriptions  =  infinity

  ## @path mqtt.upgrade_qos
  ## @type boolean()
  ## @default false
  upgrade_qos  =  false

  ## @path mqtt.max_inflight
  ## @type 1..65535
  ## @default 32
  max_inflight  =  32

  ## @path mqtt.retry_interval
  ## @type emqx_schema:duration()
  ## @default 30s
  retry_interval  =  30s

  ## @path mqtt.max_awaiting_rel
  ## @type union() integer() | infinity
  ## @default 100
  max_awaiting_rel  =  100

  ## @path mqtt.await_rel_timeout
  ## @type emqx_schema:duration()
  ## @default 300s
  await_rel_timeout  =  300s

  ## @path mqtt.session_expiry_interval
  ## @type emqx_schema:duration()
  ## @default 2h
  session_expiry_interval  =  2h

  ## @path mqtt.max_mqueue_len
  ## @type union() non_neg_integer() | infinity
  ## @default 1000
  max_mqueue_len  =  1000

  ## @path mqtt.mqueue_priorities
  ## @type union() disabled | map()
  ## @default disabled
  mqueue_priorities  =  disabled

  ## @path mqtt.mqueue_default_priority
  ## @type enum: highest | lowest
  ## @default lowest
  mqueue_default_priority  =  lowest

  ## @path mqtt.mqueue_store_qos0
  ## @type boolean()
  ## @default true
  mqueue_store_qos0  =  true

  ## @path mqtt.use_username_as_clientid
  ## @type boolean()
  ## @default false
  use_username_as_clientid  =  false

  ## @path mqtt.peer_cert_as_username
  ## @type enum: disabled | cn | dn | crt | pem | md5
  ## @default disabled
  peer_cert_as_username  =  disabled

  ## @path mqtt.peer_cert_as_clientid
  ## @type enum: disabled | cn | dn | crt | pem | md5
  ## @default disabled
  peer_cert_as_clientid  =  disabled
 }
## @path zones
## @type map_struct()
  #  zones.name  =
  ## @path zones.$name
  #   {
    ## @path zones.$name.mqtt
    #  mqtt {
      ## @path zones.$name.mqtt.idle_timeout
      ## @type union() infinity | emqx_schema:duration()
      #  idle_timeout  =

      ## @path zones.$name.mqtt.max_packet_size
      ## @type emqx_schema:bytesize()
      #  max_packet_size  =

      ## @path zones.$name.mqtt.max_clientid_len
      ## @type 23..65535
      #  max_clientid_len  =

      ## @path zones.$name.mqtt.max_topic_levels
      ## @type 1..65535
      #  max_topic_levels  =

      ## @path zones.$name.mqtt.max_qos_allowed
      ## @type qos()
      #  max_qos_allowed  =

      ## @path zones.$name.mqtt.max_topic_alias
      ## @type 0..65535
      #  max_topic_alias  =

      ## @path zones.$name.mqtt.retain_available
      ## @type boolean()
      #  retain_available  =

      ## @path zones.$name.mqtt.wildcard_subscription
      ## @type boolean()
      #  wildcard_subscription  =

      ## @path zones.$name.mqtt.shared_subscription
      ## @type boolean()
      #  shared_subscription  =

      ## @path zones.$name.mqtt.exclusive_subscription
      ## @type boolean()
      #  exclusive_subscription  =

      ## @path zones.$name.mqtt.ignore_loop_deliver
      ## @type boolean()
      #  ignore_loop_deliver  =

      ## @path zones.$name.mqtt.strict_mode
      ## @type boolean()
      #  strict_mode  =

      ## @path zones.$name.mqtt.response_information
      ## @type string()
      #  response_information  =

      ## @path zones.$name.mqtt.server_keepalive
      ## @type union() integer() | disabled
      #  server_keepalive  =

      ## @path zones.$name.mqtt.keepalive_multiplier
      ## @type number()
      #  keepalive_multiplier  =

      ## @path zones.$name.mqtt.max_subscriptions
      ## @type union() 1..inf | infinity
      #  max_subscriptions  =

      ## @path zones.$name.mqtt.upgrade_qos
      ## @type boolean()
      #  upgrade_qos  =

      ## @path zones.$name.mqtt.max_inflight
      ## @type 1..65535
      #  max_inflight  =

      ## @path zones.$name.mqtt.retry_interval
      ## @type emqx_schema:duration()
      #  retry_interval  =

      ## @path zones.$name.mqtt.max_awaiting_rel
      ## @type union() integer() | infinity
      #  max_awaiting_rel  =

      ## @path zones.$name.mqtt.await_rel_timeout
      ## @type emqx_schema:duration()
      #  await_rel_timeout  =

      ## @path zones.$name.mqtt.session_expiry_interval
      ## @type emqx_schema:duration()
      #  session_expiry_interval  =

      ## @path zones.$name.mqtt.max_mqueue_len
      ## @type union() non_neg_integer() | infinity
      #  max_mqueue_len  =

      ## @path zones.$name.mqtt.mqueue_priorities
      ## @type union() disabled | map()
      #  mqueue_priorities  =

      ## @path zones.$name.mqtt.mqueue_default_priority
      ## @type enum: highest | lowest
      #  mqueue_default_priority  =

      ## @path zones.$name.mqtt.mqueue_store_qos0
      ## @type boolean()
      #  mqueue_store_qos0  =

      ## @path zones.$name.mqtt.use_username_as_clientid
      ## @type boolean()
      #  use_username_as_clientid  =

      ## @path zones.$name.mqtt.peer_cert_as_username
      ## @type enum: disabled | cn | dn | crt | pem | md5
      #  peer_cert_as_username  =

      ## @path zones.$name.mqtt.peer_cert_as_clientid
      ## @type enum: disabled | cn | dn | crt | pem | md5
      #  peer_cert_as_clientid  =
    #   }

    ## @path zones.$name.flapping_detect
    #  flapping_detect {
      ## @path zones.$name.flapping_detect.enable
      ## @type boolean()
      #  enable  =

      ## @path zones.$name.flapping_detect.window_time
      ## @type emqx_schema:duration()
      #  window_time  =

      ## @path zones.$name.flapping_detect.max_count
      ## @type non_neg_integer()
      #  max_count  =

      ## @path zones.$name.flapping_detect.ban_time
      ## @type emqx_schema:duration()
      #  ban_time  =
    #   }

    ## @path zones.$name.force_shutdown
    #  force_shutdown {
      ## @path zones.$name.force_shutdown.enable
      ## @type boolean()
      #  enable  =

      ## @path zones.$name.force_shutdown.max_mailbox_size
      ## @type 0..inf
      #  max_mailbox_size  =

      ## @path zones.$name.force_shutdown.max_heap_size
      ## @type emqx_schema:wordsize()
      #  max_heap_size  =
    #   }

    ## @path zones.$name.force_gc
    #  force_gc {
      ## @path zones.$name.force_gc.enable
      ## @type boolean()
      #  enable  =

      ## @path zones.$name.force_gc.count
      ## @type 0..inf
      #  count  =

      ## @path zones.$name.force_gc.bytes
      ## @type emqx_schema:bytesize()
      #  bytes  =
    #   }
  #   }

## @path authentication
## @type array()
## @default []
authentication  =  []
## @path authorization
authorization {
  ## @path authorization.no_match
  ## @type enum: allow | deny
  ## @default allow
  no_match  =  deny

  ## @path authorization.deny_action
  ## @type enum: ignore | disconnect
  ## @default ignore
  deny_action  =  ignore

  ## @path authorization.cache
  cache {
    ## @path authorization.cache.enable
    ## @type boolean()
    ## @default true
    enable  =  true

    ## @path authorization.cache.max_size
    ## @type 1..1048576
    ## @default 32
    max_size  =  32

    ## @path authorization.cache.ttl
    ## @type emqx_schema:duration()
    ## @default 1m
    ttl  =  1m
   }

  ## @path authorization.sources
  ## @type array()
  ## @default
    #  [  {    enable = true    path = "${EMQX_ETC_DIR}/acl.conf"    type = "file"  }]

  sources  =  []

 }
## @path node
node {
  ## @path node.name
  ## @type string()
  ## @default "emqx@127.0.0.1"
  name  =  "emqx@127.0.0.1"

  ## @path node.cookie
  ## @type string()
  cookie  =  emqxsecretcookie

  ## @path node.process_limit
  ## @type 1024..134217727
  ## @default 2097152
  process_limit  =  2097152

  ## @path node.max_ports
  ## @type 1024..134217727
  ## @default 1048576
  max_ports  =  1048576

  ## @path node.dist_buffer_size
  ## @type 1..2097151
  ## @default 8192
  dist_buffer_size  =  8192

  ## @path node.data_dir
  ## @type string()
  #  data_dir  =

  ## @path node.global_gc_interval
  ## @type union() disabled | emqx_schema:duration()
  ## @default 15m
  global_gc_interval  =  15m

  ## @path node.role
  ## @type enum: core | replicant
  ## @default core
  role  =  core
 }
## @path cluster
cluster {
  ## @path cluster.name
  ## @type atom()
  ## @default emqxcl
  name  =  emqxcl

  ## @path cluster.discovery_strategy
  ## @type enum: manual | static | dns | etcd | k8s | mcast
  ## @default manual
  discovery_strategy  =  manual

  ## @path cluster.core_nodes
  ## @type union() emqx_schema:comma_separated_atoms() | [atom()]
  ## @default []
  core_nodes  =  []

  ## @path cluster.autoclean
  ## @type emqx_schema:duration()
  ## @default 5m
  autoclean  =  5m

  ## @path cluster.autoheal
  ## @type boolean()
  ## @default true
  autoheal  =  true

  ## @path cluster.proto_dist
  ## @type enum: inet_tcp | inet6_tcp | inet_tls
  ## @default inet_tcp
  proto_dist  =  inet_tcp

  ## @path cluster.static
  static {
    ## @path cluster.static.seeds
    ## @type union() emqx_schema:comma_separated_atoms() | [atom()]
    ## @default []
    ## @link cluster.core_nodes
    seeds  =  []
   }

  ## @path cluster.dns
  dns {
    ## @path cluster.dns.name
    ## @type string()
    ## @default localhost
    name  =  localhost

    ## @path cluster.dns.record_type
    ## @type enum: a | srv
    ## @default a
    record_type  =  a
   }

  ## @path cluster.etcd
  etcd {
    ## @path cluster.etcd.server
    ## @type emqx_schema:comma_separated_list()
    #  server  =

    ## @path cluster.etcd.prefix
    ## @type string()
    ## @default emqxcl
    prefix  =  emqxcl

    ## @path cluster.etcd.node_ttl
    ## @type emqx_schema:duration()
    ## @default 1m
    node_ttl  =  1m

    ## @path cluster.etcd.ssl_options
    ssl_options {
      ## @path cluster.etcd.ssl_options.cacertfile
      ## @type binary()
      #  cacertfile  =

      ## @path cluster.etcd.ssl_options.certfile
      ## @type binary()
      #  certfile  =

      ## @path cluster.etcd.ssl_options.keyfile
      ## @type binary()
      #  keyfile  =

      ## @path cluster.etcd.ssl_options.verify
      ## @type enum: verify_peer | verify_none
      ## @default verify_none
      verify  =  verify_peer

      ## @path cluster.etcd.ssl_options.reuse_sessions
      ## @type boolean()
      ## @default true
      reuse_sessions  =  true

      ## @path cluster.etcd.ssl_options.depth
      ## @type integer()
      ## @default 10
      depth  =  10

      ## @path cluster.etcd.ssl_options.password
      ## @type string()
      #  password  =

      ## @path cluster.etcd.ssl_options.versions
      ## @type array()
      ## @default [tlsv1.3, tlsv1.2]
      versions  =  [tlsv1.3, tlsv1.2]

      ## @path cluster.etcd.ssl_options.ciphers
      ## @type array()
      ## @default []
      ciphers  =  []

      ## @path cluster.etcd.ssl_options.secure_renegotiate
      ## @type boolean()
      ## @default true
      secure_renegotiate  =  true

      ## @path cluster.etcd.ssl_options.log_level
      ## @type enum: emergency | alert | critical | error | warning | notice | info | debug | none | all
      ## @default notice
      log_level  =  notice

      ## @path cluster.etcd.ssl_options.hibernate_after
      ## @type emqx_schema:duration()
      ## @default 5s
      hibernate_after  =  5s

      ## @path cluster.etcd.ssl_options.enable
      ## @type boolean()
      ## @default false
      enable  =  false

      ## @path cluster.etcd.ssl_options.server_name_indication
      ## @type union() disable | string()
      server_name_indication  =  disable
     }
   }

  ## @path cluster.k8s
  k8s {
    ## @path cluster.k8s.apiserver
    ## @type string()
    ## @default "http://10.110.111.204:8080"
    apiserver  =  "http://10.110.111.204:8080"

    ## @path cluster.k8s.service_name
    ## @type string()
    ## @default emqx
    service_name  =  emqx

    ## @path cluster.k8s.address_type
    ## @type enum: ip | dns | hostname
    ## @default ip
    address_type  =  ip

    ## @path cluster.k8s.namespace
    ## @type string()
    ## @default default
    namespace  =  default

    ## @path cluster.k8s.suffix
    ## @type string()
    ## @default "pod.local"
    suffix  =  "pod.local"
   }
 }
## @path log
log {
  ## @path log.console
  console {
    ## @path log.console.level
    ## @type emqx_conf_schema:log_level()
    ## @default warning
    level  =  warning

    ## @path log.console.enable
    ## @type boolean()
    ## @default false
    enable  =  false

    ## @path log.console.formatter
    ## @type enum: text | json
    ## @default text
    formatter  =  text

    ## @path log.console.time_offset
    ## @type string()
    ## @default system
    time_offset  =  system
   }

  ## @path log.file
  ## @type union() log_file_handler | handler_name
  ## @default {level = "warning"}
  file  =  {level = "warning"}
 }
## @path rpc
rpc {
  ## @path rpc.mode
  ## @type enum: sync | async
  ## @default async
  mode  =  async

  ## @path rpc.protocol
  ## @type enum: tcp | ssl
  ## @default tcp
  protocol  =  tcp

  ## @path rpc.async_batch_size
  ## @type integer()
  ## @default 256
  async_batch_size  =  256

  ## @path rpc.port_discovery
  ## @type enum: manual | stateless
  ## @default stateless
  port_discovery  =  stateless

  ## @path rpc.tcp_server_port
  ## @type integer()
  ## @default 5369
  tcp_server_port  =  5369

  ## @path rpc.ssl_server_port
  ## @type integer()
  ## @default 5369
  ssl_server_port  =  5369

  ## @path rpc.tcp_client_num
  ## @type 1..256
  ## @default 10
  tcp_client_num  =  10

  ## @path rpc.connect_timeout
  ## @type emqx_schema:duration()
  ## @default 5s
  connect_timeout  =  5s

  ## @path rpc.certfile
  ## @type emqx_conf_schema:file()
  #  certfile  =

  ## @path rpc.keyfile
  ## @type emqx_conf_schema:file()
  #  keyfile  =

  ## @path rpc.cacertfile
  ## @type emqx_conf_schema:file()
  #  cacertfile  =

  ## @path rpc.send_timeout
  ## @type emqx_schema:duration()
  ## @default 5s
  send_timeout  =  5s

  ## @path rpc.authentication_timeout
  ## @type emqx_schema:duration()
  ## @default 5s
  authentication_timeout  =  5s

  ## @path rpc.call_receive_timeout
  ## @type emqx_schema:duration()
  ## @default 15s
  call_receive_timeout  =  15s

  ## @path rpc.socket_keepalive_idle
  ## @type emqx_schema:timeout_duration_s()
  ## @default 15m
  socket_keepalive_idle  =  15m

  ## @path rpc.socket_keepalive_interval
  ## @type emqx_schema:timeout_duration_s()
  ## @default 75s
  socket_keepalive_interval  =  75s

  ## @path rpc.socket_keepalive_count
  ## @type integer()
  ## @default 9
  socket_keepalive_count  =  9

  ## @path rpc.socket_sndbuf
  ## @type emqx_schema:bytesize()
  ## @default 1MB
  socket_sndbuf  =  1MB

  ## @path rpc.socket_recbuf
  ## @type emqx_schema:bytesize()
  ## @default 1MB
  socket_recbuf  =  1MB

  ## @path rpc.socket_buffer
  ## @type emqx_schema:bytesize()
  ## @default 1MB
  socket_buffer  =  1MB

  ## @path rpc.insecure_fallback
  ## @type boolean()
  ## @default true
  insecure_fallback  =  false
 }
## @path broker
broker {
  ## @path broker.enable_session_registry
  ## @type boolean()
  ## @default true
  enable_session_registry  =  true

  ## @path broker.session_locking_strategy
  ## @type enum: local | leader | quorum | all
  ## @default quorum
  session_locking_strategy  =  quorum

  ## @path broker.shared_subscription_strategy
  ## @type enum: random | round_robin | round_robin_per_group | sticky | local | hash_topic | hash_clientid
  ## @default round_robin
  shared_subscription_strategy  =  round_robin
 }
## @path sys_topics
sys_topics {
  ## @path sys_topics.sys_msg_interval
  ## @type union() disabled | emqx_schema:duration()
  ## @default 1m
  sys_msg_interval  =  1m

  ## @path sys_topics.sys_heartbeat_interval
  ## @type union() disabled | emqx_schema:duration()
  ## @default 30s
  sys_heartbeat_interval  =  30s

  ## @path sys_topics.sys_event_messages
  sys_event_messages {
    ## @path sys_topics.sys_event_messages.client_connected
    ## @type boolean()
    ## @default true
    client_connected  =  true

    ## @path sys_topics.sys_event_messages.client_disconnected
    ## @type boolean()
    ## @default true
    client_disconnected  =  true

    ## @path sys_topics.sys_event_messages.client_subscribed
    ## @type boolean()
    ## @default false
    client_subscribed  =  false

    ## @path sys_topics.sys_event_messages.client_unsubscribed
    ## @type boolean()
    ## @default false
    client_unsubscribed  =  false
   }
 }
## @path force_shutdown
force_shutdown {
  ## @path force_shutdown.enable
  ## @type boolean()
  ## @default true
  enable  =  false

  ## @path force_shutdown.max_mailbox_size
  ## @type 0..inf
  ## @default 1000
  max_mailbox_size  =  1000

  ## @path force_shutdown.max_heap_size
  ## @type emqx_schema:wordsize()
  ## @default 32MB
  max_heap_size  =  32MB
 }
## @path force_gc
force_gc {
  ## @path force_gc.enable
  ## @type boolean()
  ## @default true
  enable  =  true

  ## @path force_gc.count
  ## @type 0..inf
  ## @default 16000
  count  =  16000

  ## @path force_gc.bytes
  ## @type emqx_schema:bytesize()
  ## @default 16MB
  bytes  =  16MB
 }
## @path sysmon
sysmon {
  ## @path sysmon.vm
  vm {
    ## @path sysmon.vm.process_check_interval
    ## @type emqx_schema:duration()
    ## @default 30s
    process_check_interval  =  30s

    ## @path sysmon.vm.process_high_watermark
    ## @type emqx_schema:percent()
    ## @default "80%"
    process_high_watermark  =  "80%"

    ## @path sysmon.vm.process_low_watermark
    ## @type emqx_schema:percent()
    ## @default "60%"
    process_low_watermark  =  "60%"

    ## @path sysmon.vm.long_gc
    ## @type union() disabled | emqx_schema:duration()
    ## @default disabled
    long_gc  =  disabled

    ## @path sysmon.vm.long_schedule
    ## @type union() disabled | emqx_schema:duration()
    ## @default 240ms
    long_schedule  =  240ms

    ## @path sysmon.vm.large_heap
    ## @type union() disabled | emqx_schema:bytesize()
    ## @default 32MB
    large_heap  =  32MB

    ## @path sysmon.vm.busy_dist_port
    ## @type boolean()
    ## @default true
    busy_dist_port  =  true

    ## @path sysmon.vm.busy_port
    ## @type boolean()
    ## @default true
    busy_port  =  true
   }

  ## @path sysmon.os
  os {
    ## @path sysmon.os.cpu_check_interval
    ## @type emqx_schema:duration()
    ## @default 60s
    cpu_check_interval  =  60s

    ## @path sysmon.os.cpu_high_watermark
    ## @type emqx_schema:percent()
    ## @default "80%"
    cpu_high_watermark  =  "80%"

    ## @path sysmon.os.cpu_low_watermark
    ## @type emqx_schema:percent()
    ## @default "60%"
    cpu_low_watermark  =  "60%"

    ## @path sysmon.os.mem_check_interval
    ## @type union() disabled | emqx_schema:duration()
    ## @default 60s
    mem_check_interval  =  60s

    ## @path sysmon.os.sysmem_high_watermark
    ## @type emqx_schema:percent()
    ## @default "70%"
    sysmem_high_watermark  =  "70%"

    ## @path sysmon.os.procmem_high_watermark
    ## @type emqx_schema:percent()
    ## @default "5%"
    procmem_high_watermark  =  "5%"
   }
 }
## @path alarm
alarm {
  ## @path alarm.actions
  ## @type array()
  ## @default [log, publish]
  actions  =  [log, publish]

  ## @path alarm.size_limit
  ## @type 1..3000
  ## @default 1000
  size_limit  =  1000

  ## @path alarm.validity_period
  ## @type emqx_schema:duration()
  ## @default 24h
  validity_period  =  24h
 }
## @path flapping_detect
flapping_detect {
  ## @path flapping_detect.enable
  ## @type boolean()
  ## @default false
  enable  =  false

  ## @path flapping_detect.window_time
  ## @type emqx_schema:duration()
  ## @default 1m
  window_time  =  1m

  ## @path flapping_detect.max_count
  ## @type non_neg_integer()
  ## @default 15
  max_count  =  15

  ## @path flapping_detect.ban_time
  ## @type emqx_schema:duration()
  ## @default 5m
  ban_time  =  5m
 }
## @path bridges
bridges {
  ## @path bridges.webhook
  ## @type map_struct()
    #  webhook.name  =
    ## @path bridges.webhook.$name
    #   {
      ## @path bridges.webhook.$name.enable
      ## @type boolean()
      ## @default true
      #  enable  =  true

      ## @path bridges.webhook.$name.resource_opts
      #  resource_opts {
        ## @path bridges.webhook.$name.resource_opts.worker_pool_size
        ## @type non_neg_integer()
        ## @default 16
        #  worker_pool_size  =  16

        ## @path bridges.webhook.$name.resource_opts.health_check_interval
        ## @type emqx_schema:timeout_duration_ms()
        ## @default 15s
        #  health_check_interval  =  15s

        ## @path bridges.webhook.$name.resource_opts.start_after_created
        ## @type boolean()
        ## @default true
        #  start_after_created  =  true

        ## @path bridges.webhook.$name.resource_opts.start_timeout
        ## @type emqx_schema:timeout_duration_ms()
        ## @default 5s
        #  start_timeout  =  5s

        ## @path bridges.webhook.$name.resource_opts.auto_restart_interval
        ## @type union() infinity | emqx_schema:duration_ms()
        #  auto_restart_interval  =

        ## @path bridges.webhook.$name.resource_opts.query_mode
        ## @type enum: sync | async
        ## @default async
        #  query_mode  =  async

        ## @path bridges.webhook.$name.resource_opts.request_ttl
        ## @type union() emqx_schema:timeout_duration_ms() | infinity
        ## @default 45s
        #  request_ttl  =  45s

        ## @path bridges.webhook.$name.resource_opts.inflight_window
        ## @type pos_integer()
        ## @default 100
        #  inflight_window  =  100

        ## @path bridges.webhook.$name.resource_opts.enable_queue
        ## @type boolean()
        #  enable_queue  =

        ## @path bridges.webhook.$name.resource_opts.max_buffer_bytes
        ## @type emqx_schema:bytesize()
        ## @default 256MB
        #  max_buffer_bytes  =  256MB
      #   }

      ## @path bridges.webhook.$name.connect_timeout
      ## @type emqx_schema:timeout_duration_ms()
      ## @default 15s
      #  connect_timeout  =  15s

      ## @path bridges.webhook.$name.retry_interval
      ## @type emqx_schema:timeout_duration()
      #  retry_interval  =

      ## @path bridges.webhook.$name.pool_type
      ## @type emqx_connector_http:pool_type()
      ## @default random
      #  pool_type  =  random

      ## @path bridges.webhook.$name.pool_size
      ## @type pos_integer()
      ## @default 8
      #  pool_size  =  8

      ## @path bridges.webhook.$name.enable_pipelining
      ## @type pos_integer()
      ## @default 100
      #  enable_pipelining  =  100

      ## @path bridges.webhook.$name.request
      #  request {
        ## @path bridges.webhook.$name.request.method
        ## @type binary()
        #  method  =

        ## @path bridges.webhook.$name.request.path
        ## @type binary()
        #  path  =

        ## @path bridges.webhook.$name.request.body
        ## @type binary()
        #  body  =

        ## @path bridges.webhook.$name.request.headers
        ## @type map()
        #  headers  =

        ## @path bridges.webhook.$name.request.max_retries
        ## @type non_neg_integer()
        #  max_retries  =

        ## @path bridges.webhook.$name.request.request_timeout
        ## @type emqx_schema:timeout_duration_ms()
        #  request_timeout  =
      #   }

      ## @path bridges.webhook.$name.ssl
      ## @link cluster.etcd.ssl_options
      #  ssl {
        ## @path bridges.webhook.$name.ssl.cacertfile
        ## @type binary()
        #  cacertfile  =

        ## @path bridges.webhook.$name.ssl.certfile
        ## @type binary()
        #  certfile  =

        ## @path bridges.webhook.$name.ssl.keyfile
        ## @type binary()
        #  keyfile  =

        ## @path bridges.webhook.$name.ssl.verify
        ## @type enum: verify_peer | verify_none
        ## @default verify_none
        #  verify  =  verify_none

        ## @path bridges.webhook.$name.ssl.reuse_sessions
        ## @type boolean()
        ## @default true
        #  reuse_sessions  =  true

        ## @path bridges.webhook.$name.ssl.depth
        ## @type integer()
        ## @default 10
        #  depth  =  10

        ## @path bridges.webhook.$name.ssl.password
        ## @type string()
        #  password  =

        ## @path bridges.webhook.$name.ssl.versions
        ## @type array()
        ## @default [tlsv1.3, tlsv1.2]
        #  versions  =  [tlsv1.3, tlsv1.2]

        ## @path bridges.webhook.$name.ssl.ciphers
        ## @type array()
        ## @default []
        #  ciphers  =  []

        ## @path bridges.webhook.$name.ssl.secure_renegotiate
        ## @type boolean()
        ## @default true
        #  secure_renegotiate  =  true

        ## @path bridges.webhook.$name.ssl.log_level
        ## @type enum: emergency | alert | critical | error | warning | notice | info | debug | none | all
        ## @default notice
        #  log_level  =  notice

        ## @path bridges.webhook.$name.ssl.hibernate_after
        ## @type emqx_schema:duration()
        ## @default 5s
        #  hibernate_after  =  5s

        ## @path bridges.webhook.$name.ssl.enable
        ## @type boolean()
        ## @default false
        #  enable  =  false

        ## @path bridges.webhook.$name.ssl.server_name_indication
        ## @type union() disable | string()
        #  server_name_indication  =  disable
      #   }

      ## @path bridges.webhook.$name.url
      ## @type binary()
      #  url  =

      ## @path bridges.webhook.$name.direction
      ## @type singleton
      #  direction  =  egress

      ## @path bridges.webhook.$name.local_topic
      ## @type binary()
      #  local_topic  =

      ## @path bridges.webhook.$name.method
      ## @type enum: post | put | get | delete
      ## @default post
      #  method  =  post

      ## @path bridges.webhook.$name.headers
      ## @type map()
      ## @default
        #  {  accept = "application/json"  "cache-control" = "no-cache"  connection = "keep-alive"  "content-type" = "application/json"  "keep-alive" = "timeout=5"}

      #  headers  =
        #  {  accept = "application/json"  "cache-control" = "no-cache"  connection = "keep-alive"  "content-type" = "application/json"  "keep-alive" = "timeout=5"}


      ## @path bridges.webhook.$name.body
      ## @type binary()
      #  body  =

      ## @path bridges.webhook.$name.max_retries
      ## @type non_neg_integer()
      ## @default 2
      #  max_retries  =  2

      ## @path bridges.webhook.$name.request_timeout
      ## @type emqx_schema:duration_ms()
      #  request_timeout  =
    #   }


  ## @path bridges.mqtt
  ## @type map_struct()
    #  mqtt.name  =
    ## @path bridges.mqtt.$name
    #   {
      ## @path bridges.mqtt.$name.enable
      ## @type boolean()
      ## @default true
      #  enable  =  true

      ## @path bridges.mqtt.$name.resource_opts
      #  resource_opts {
        ## @path bridges.mqtt.$name.resource_opts.worker_pool_size
        ## @type non_neg_integer()
        ## @default 16
        #  worker_pool_size  =  16

        ## @path bridges.mqtt.$name.resource_opts.health_check_interval
        ## @type emqx_schema:timeout_duration_ms()
        ## @default 15s
        #  health_check_interval  =  15s

        ## @path bridges.mqtt.$name.resource_opts.start_after_created
        ## @type boolean()
        ## @default true
        #  start_after_created  =  true

        ## @path bridges.mqtt.$name.resource_opts.start_timeout
        ## @type emqx_schema:timeout_duration_ms()
        ## @default 5s
        #  start_timeout  =  5s

        ## @path bridges.mqtt.$name.resource_opts.auto_restart_interval
        ## @type union() infinity | emqx_schema:duration_ms()
        #  auto_restart_interval  =

        ## @path bridges.mqtt.$name.resource_opts.query_mode
        ## @type enum: sync | async
        ## @default async
        #  query_mode  =  async

        ## @path bridges.mqtt.$name.resource_opts.request_ttl
        ## @type union() emqx_schema:timeout_duration_ms() | infinity
        ## @default 45s
        #  request_ttl  =  45s

        ## @path bridges.mqtt.$name.resource_opts.inflight_window
        ## @type pos_integer()
        ## @default 100
        #  inflight_window  =  100

        ## @path bridges.mqtt.$name.resource_opts.enable_queue
        ## @type boolean()
        #  enable_queue  =

        ## @path bridges.mqtt.$name.resource_opts.max_buffer_bytes
        ## @type emqx_schema:bytesize()
        ## @default 256MB
        #  max_buffer_bytes  =  256MB
      #   }

      ## @path bridges.mqtt.$name.mode
      ## @type enum: cluster_shareload
      #  mode  =

      ## @path bridges.mqtt.$name.server
      ## @type string()
      #  server  =

      ## @path bridges.mqtt.$name.clientid_prefix
      ## @type binary()
      #  clientid_prefix  =

      ## @path bridges.mqtt.$name.reconnect_interval
      ## @type string()
      #  reconnect_interval  =

      ## @path bridges.mqtt.$name.proto_ver
      ## @type enum: v3 | v4 | v5
      ## @default v4
      #  proto_ver  =  v4

      ## @path bridges.mqtt.$name.bridge_mode
      ## @type boolean()
      ## @default false
      #  bridge_mode  =  false

      ## @path bridges.mqtt.$name.username
      ## @type binary()
      #  username  =

      ## @path bridges.mqtt.$name.password
      ## @type binary()
      #  password  =

      ## @path bridges.mqtt.$name.clean_start
      ## @type boolean()
      ## @default true
      #  clean_start  =  true

      ## @path bridges.mqtt.$name.keepalive
      ## @type string()
      ## @default 300s
      #  keepalive  =  300s

      ## @path bridges.mqtt.$name.retry_interval
      ## @type string()
      ## @default 15s
      #  retry_interval  =  15s

      ## @path bridges.mqtt.$name.max_inflight
      ## @type non_neg_integer()
      ## @default 32
      #  max_inflight  =  32

      ## @path bridges.mqtt.$name.ssl
      ## @link cluster.etcd.ssl_options
      #  ssl {
        ## @path bridges.mqtt.$name.ssl.cacertfile
        ## @type binary()
        #  cacertfile  =

        ## @path bridges.mqtt.$name.ssl.certfile
        ## @type binary()
        #  certfile  =

        ## @path bridges.mqtt.$name.ssl.keyfile
        ## @type binary()
        #  keyfile  =

        ## @path bridges.mqtt.$name.ssl.verify
        ## @type enum: verify_peer | verify_none
        ## @default verify_none
        #  verify  =  verify_none

        ## @path bridges.mqtt.$name.ssl.reuse_sessions
        ## @type boolean()
        ## @default true
        #  reuse_sessions  =  true

        ## @path bridges.mqtt.$name.ssl.depth
        ## @type integer()
        ## @default 10
        #  depth  =  10

        ## @path bridges.mqtt.$name.ssl.password
        ## @type string()
        #  password  =

        ## @path bridges.mqtt.$name.ssl.versions
        ## @type array()
        ## @default [tlsv1.3, tlsv1.2]
        #  versions  =  [tlsv1.3, tlsv1.2]

        ## @path bridges.mqtt.$name.ssl.ciphers
        ## @type array()
        ## @default []
        #  ciphers  =  []

        ## @path bridges.mqtt.$name.ssl.secure_renegotiate
        ## @type boolean()
        ## @default true
        #  secure_renegotiate  =  true

        ## @path bridges.mqtt.$name.ssl.log_level
        ## @type enum: emergency | alert | critical | error | warning | notice | info | debug | none | all
        ## @default notice
        #  log_level  =  notice

        ## @path bridges.mqtt.$name.ssl.hibernate_after
        ## @type emqx_schema:duration()
        ## @default 5s
        #  hibernate_after  =  5s

        ## @path bridges.mqtt.$name.ssl.enable
        ## @type boolean()
        ## @default false
        #  enable  =  false

        ## @path bridges.mqtt.$name.ssl.server_name_indication
        ## @type union() disable | string()
        #  server_name_indication  =  disable
      #   }

      ## @path bridges.mqtt.$name.ingress
      #  ingress {
        ## @path bridges.mqtt.$name.ingress.pool_size
        ## @type pos_integer()
        ## @default 8
        #  pool_size  =  8

        ## @path bridges.mqtt.$name.ingress.remote
        #  remote {
          ## @path bridges.mqtt.$name.ingress.remote.topic
          ## @type binary()
          #  topic  =

          ## @path bridges.mqtt.$name.ingress.remote.qos
          ## @type qos()
          ## @default 1
          #  qos  =  1
        #   }

        ## @path bridges.mqtt.$name.ingress.local
        #  local {
          ## @path bridges.mqtt.$name.ingress.local.topic
          ## @type binary()
          #  topic  =

          ## @path bridges.mqtt.$name.ingress.local.qos
          ## @type union() qos() | binary()
          ## @default "${qos}"
          #  qos  =  "${qos}"

          ## @path bridges.mqtt.$name.ingress.local.retain
          ## @type union() boolean() | binary()
          ## @default "${retain}"
          #  retain  =  "${retain}"

          ## @path bridges.mqtt.$name.ingress.local.payload
          ## @type binary()
          #  payload  =
        #   }
      #   }

      ## @path bridges.mqtt.$name.egress
      #  egress {
        ## @path bridges.mqtt.$name.egress.pool_size
        ## @type pos_integer()
        ## @default 8
        #  pool_size  =  8

        ## @path bridges.mqtt.$name.egress.local
        #  local {
          ## @path bridges.mqtt.$name.egress.local.topic
          ## @type binary()
          #  topic  =
        #   }

        ## @path bridges.mqtt.$name.egress.remote
        #  remote {
          ## @path bridges.mqtt.$name.egress.remote.topic
          ## @type binary()
          #  topic  =

          ## @path bridges.mqtt.$name.egress.remote.qos
          ## @type union() qos() | binary()
          ## @default 1
          #  qos  =  1

          ## @path bridges.mqtt.$name.egress.remote.retain
          ## @type union() boolean() | binary()
          ## @default false
          #  retain  =  false

          ## @path bridges.mqtt.$name.egress.remote.payload
          ## @type binary()
          #  payload  =
        #   }
      #   }
    #   }

 }
## @path retainer
retainer {
  ## @path retainer.enable
  ## @type boolean()
  ## @default true
  enable  =  true

  ## @path retainer.msg_expiry_interval
  ## @type emqx_schema:duration_ms()
  ## @default 0s
  msg_expiry_interval  =  0s

  ## @path retainer.msg_clear_interval
  ## @type emqx_schema:timeout_duration_ms()
  ## @default 0s
  msg_clear_interval  =  0s

  ## @path retainer.max_payload_size
  ## @type emqx_schema:bytesize()
  ## @default 1MB
  max_payload_size  =  1MB

  ## @path retainer.stop_publish_clear_msg
  ## @type boolean()
  ## @default false
  stop_publish_clear_msg  =  false

  ## @path retainer.deliver_rate
  ## @type emqx_limiter_schema:rate()
  deliver_rate  =  "1000/s"

  ## @path retainer.backend
  backend {
    ## @path retainer.backend.type
    ## @type singleton
    ## @default built_in_database
    type  =  built_in_database

    ## @path retainer.backend.storage_type
    ## @type enum: ram | disc
    ## @default ram
    storage_type  =  ram

    ## @path retainer.backend.max_retained_messages
    ## @type non_neg_integer()
    ## @default 0
    max_retained_messages  =  0

    ## @path retainer.backend.index_specs
    ## @type [[integer()]]
    ## @default
      #  [  [1, 2, 3],  [1, 3],  [2, 3],  [3]]

    index_specs  =
      [  [2, 4],  [1, 3]]

   }
 }
## @path telemetry
telemetry {
  ## @path telemetry.enable
  ## @type boolean()
  #  enable  =
 }
## @path delayed
delayed {
  ## @path delayed.enable
  ## @type boolean()
  ## @default true
  enable  =  true

  ## @path delayed.max_delayed_messages
  ## @type integer()
  ## @default 0
  max_delayed_messages  =  0
 }
## @path plugins
plugins {
  ## @path plugins.states
  ## @type array()
  ## @default []
  states  =  [{name_vsn = "gg-1.0.0", enable = true}]

  ## @path plugins.install_dir
  ## @type string()
  ## @default plugins
  install_dir  =  plugins

  ## @path plugins.check_interval
  ## @type emqx_schema:duration()
  #  check_interval  =
 }
## @path dashboard
dashboard {
  ## @path dashboard.listeners
  listeners {
    ## @path dashboard.listeners.http
    http {
      ## @path dashboard.listeners.http.enable
      ## @type boolean()
      ## @default true
      enable  =  false

      ## @path dashboard.listeners.http.bind
      ## @type union() non_neg_integer() | emqx_schema:ip_port()
      ## @default 18083
      bind  =  "0.0.0.0:18083"

      ## @path dashboard.listeners.http.num_acceptors
      ## @type integer()
      ## @default 16
      num_acceptors  =  16

      ## @path dashboard.listeners.http.max_connections
      ## @type integer()
      ## @default 512
      max_connections  =  512

      ## @path dashboard.listeners.http.backlog
      ## @type integer()
      ## @default 1024
      backlog  =  1024

      ## @path dashboard.listeners.http.send_timeout
      ## @type emqx_schema:duration()
      ## @default 10s
      send_timeout  =  10s

      ## @path dashboard.listeners.http.inet6
      ## @type boolean()
      ## @default false
      inet6  =  false

      ## @path dashboard.listeners.http.ipv6_v6only
      ## @type boolean()
      ## @default false
      ipv6_v6only  =  false

      ## @path dashboard.listeners.http.proxy_header
      ## @type boolean()
      ## @default false
      proxy_header  =  false
     }

    ## @path dashboard.listeners.https
    https {
      ## @path dashboard.listeners.https.enable
      ## @type boolean()
      ## @default false
      enable  =  false

      ## @path dashboard.listeners.https.bind
      ## @type union() non_neg_integer() | emqx_schema:ip_port()
      ## @default 18084
      bind  =  "0.0.0.0:18084"

      ## @path dashboard.listeners.https.num_acceptors
      ## @type integer()
      ## @default 16
      num_acceptors  =  16

      ## @path dashboard.listeners.https.max_connections
      ## @type integer()
      ## @default 512
      max_connections  =  512

      ## @path dashboard.listeners.https.backlog
      ## @type integer()
      ## @default 1024
      backlog  =  1024

      ## @path dashboard.listeners.https.send_timeout
      ## @type emqx_schema:duration()
      ## @default 10s
      send_timeout  =  10s

      ## @path dashboard.listeners.https.inet6
      ## @type boolean()
      ## @default false
      inet6  =  false

      ## @path dashboard.listeners.https.ipv6_v6only
      ## @type boolean()
      ## @default false
      ipv6_v6only  =  false

      ## @path dashboard.listeners.https.proxy_header
      ## @type boolean()
      ## @default false
      proxy_header  =  false

      ## @path dashboard.listeners.https.cacertfile
      ## @type binary()
      ## @default "${EMQX_ETC_DIR}/certs/cacert.pem"
      cacertfile  =  "${EMQX_ETC_DIR}/certs/cacert.pem"

      ## @path dashboard.listeners.https.certfile
      ## @type binary()
      ## @default "${EMQX_ETC_DIR}/certs/cert.pem"
      certfile  =  "${EMQX_ETC_DIR}/certs/cert.pem"

      ## @path dashboard.listeners.https.keyfile
      ## @type binary()
      ## @default "${EMQX_ETC_DIR}/certs/key.pem"
      keyfile  =  "${EMQX_ETC_DIR}/certs/key.pem"

      ## @path dashboard.listeners.https.verify
      ## @type enum: verify_peer | verify_none
      ## @default verify_none
      verify  =  verify_none

      ## @path dashboard.listeners.https.reuse_sessions
      ## @type boolean()
      ## @default true
      reuse_sessions  =  true

      ## @path dashboard.listeners.https.depth
      ## @type integer()
      ## @default 10
      depth  =  10

      ## @path dashboard.listeners.https.password
      ## @type string()
      #  password  =

      ## @path dashboard.listeners.https.versions
      ## @type array()
      ## @default [tlsv1.3, tlsv1.2]
      versions  =  [tlsv1.3, tlsv1.2]

      ## @path dashboard.listeners.https.ciphers
      ## @type array()
      ## @default []
      ciphers  =  []

      ## @path dashboard.listeners.https.secure_renegotiate
      ## @type boolean()
      ## @default true
      secure_renegotiate  =  true

      ## @path dashboard.listeners.https.log_level
      ## @type enum: emergency | alert | critical | error | warning | notice | info | debug | none | all
      ## @default notice
      log_level  =  notice

      ## @path dashboard.listeners.https.hibernate_after
      ## @type emqx_schema:duration()
      ## @default 5s
      hibernate_after  =  5s

      ## @path dashboard.listeners.https.dhfile
      ## @type string()
      #  dhfile  =

      ## @path dashboard.listeners.https.honor_cipher_order
      ## @type boolean()
      ## @default true
      honor_cipher_order  =  true

      ## @path dashboard.listeners.https.client_renegotiation
      ## @type boolean()
      ## @default true
      client_renegotiation  =  true

      ## @path dashboard.listeners.https.handshake_timeout
      ## @type emqx_schema:duration()
      ## @default 15s
      handshake_timeout  =  15s
     }
   }

  ## @path dashboard.token_expired_time
  ## @type emqx_schema:duration()
  ## @default 60m
  token_expired_time  =  60m

  ## @path dashboard.cors
  ## @type boolean()
  ## @default false
  cors  =  false

  ## @path dashboard.bootstrap_users_file
  ## @type binary()
  #  bootstrap_users_file  =
 }
## @path prometheus
prometheus {
  ## @path prometheus.push_gateway_server
  ## @type string()
  ## @default "http://127.0.0.1:9091"
  push_gateway_server  =  "http://127.0.0.1:9091"

  ## @path prometheus.interval
  ## @type emqx_schema:timeout_duration_ms()
  ## @default 15s
  interval  =  15s

  ## @path prometheus.headers
  ## @type [{string(), string()}]
  ## @default []
  headers  =  []

  ## @path prometheus.job_name
  ## @type binary()
  ## @default "${name}/instance/${name}~${host}"
  job_name  =  "${name}/instance/${name}~${host}"

  ## @path prometheus.enable
  ## @type boolean()
  ## @default false
  enable  =  false
 }
## @path rule_engine
rule_engine {
  ## @path rule_engine.ignore_sys_message
  ## @type boolean()
  ## @default true
  ignore_sys_message  =  true

  ## @path rule_engine.jq_function_default_timeout
  ## @type emqx_schema:timeout_duration_ms()
  ## @default 10s
  jq_function_default_timeout  =  10s

  ## @path rule_engine.rules
  ## @type map_struct()
  ## @default {}
    #  rules.id  =
    ## @path rule_engine.rules.$id
    #   {
      ## @path rule_engine.rules.$id.name
      ## @type binary()
      ## @default
      #  name  =  foo

      ## @path rule_engine.rules.$id.sql
      ## @type binary()
      #  sql  =  "SELECT * FROM \"test/topic\" WHERE payload.x = 1"

      ## @path rule_engine.rules.$id.actions
      ## @type array()
      ## @default []
      #  actions  =
          #  [  "webhook:my_webhook",  {    args {payload = "${payload}", topic = "t/1"}    function = republish  },  {function = console}]


      ## @path rule_engine.rules.$id.enable
      ## @type boolean()
      ## @default true
      #  enable  =  true

      ## @path rule_engine.rules.$id.description
      ## @type binary()
      ## @default
      #  description  =  "Some description"

      ## @path rule_engine.rules.$id.metadata
      ## @type map()
      #  metadata  =
    #   }

 }
## @path exhook
exhook {
  ## @path exhook.servers
  ## @type array()
  ## @default []
  servers  =  []
 }
## @path psk_authentication
psk_authentication {
  ## @path psk_authentication.enable
  ## @type boolean()
  ## @default false
  enable  =  false

  ## @path psk_authentication.init_file
  ## @type binary()
  #  init_file  =

  ## @path psk_authentication.separator
  ## @type binary()
  ## @default ":"
  separator  =  ":"

  ## @path psk_authentication.chunk_size
  ## @type integer()
  ## @default 50
  chunk_size  =  50
 }
## @path api_key
api_key {
  ## @path api_key.bootstrap_file
  ## @type binary()
  ## @default
  bootstrap_file  = ""
 }
